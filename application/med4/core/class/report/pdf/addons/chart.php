<?php/*
 * AlcedisMED
 * Copyright (C) 2010-2016  Alcedis GmbH
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */ 

require_once( DIR_LIB . '/jpgraph/jpgraph.php'      );require_once( DIR_LIB . '/jpgraph/jpgraph_bar.php'  );require_once( DIR_LIB . '/jpgraph/jpgraph_line.php' );require_once( DIR_LIB . '/jpgraph/jpgraph_scatter.php' );class alcReportPdfAddonChart extends alcReportPdfAbstract implements alcReportPdfInterface{   private $_materialPath = 'material/';   private $_colors = array();   public function init(FPDI $fpdi)   {      $this->_materialPath .= $this->_user . '/';      $this->_fpdi = $fpdi;      $this->_buildGraphColors();      return $this;   }   /** Currently not used . When used you have to fix the color selection   public function drawAccBar($y, $xdata, $ydata = array(), $ylabels)   {      if (is_array($ydata) == false || count(reset($ydata)) == 0) {         return;      }      $pg = array();      $cO      = $this->getFPDI()->getCurrentPageOrientation();      $breite  = $this->_pageWidth[$cO] - ($this->_pageMarginLeft + $this->_pageMarginRight);      $hoehe   = 180;      $scale   = 2;      $rand = rand() . time();      $imageFilePath = $this->_materialPath . "jpgraph_{$rand}.png";      $graph = new Graph($breite * $scale, $hoehe * $scale );      $graph->SetScale('textlin');      $graph->yaxis->scale->SetGrace(10);      if (is_array($xdata) === true ) {         $graph->xaxis->SetTickLabels($xdata);      } else {         $graph->xaxis->HideLabels();      }      foreach ($ydata as $i => $bardata) {         $pg[$i] = new BarPlot($bardata);         $pg[$i]->SetFillColor($this->_colors[$i]);         $pg[$i]->SetLegend($ylabels[$i]);         $pg[$i]->value->Show();         $pg[$i]->value->setformat('%1.0f');      }      $graph->legend->SetLayout( 1 );      $graph->legend->Pos(0.5, 0.99, 'center', 'bottom');      $barplot = new AccBarPlot($pg);      $graph->Add($barplot);      $graph->SetFrame(false);      $graph->Stroke($imageFilePath);      // Graph einbinden und danach die Image-Datei löschen      $this->_fpdi->Image($imageFilePath, $this->_pageMarginLeft, $y, $breite, $hoehe);      unlink($imageFilePath);   }**/   /**  Currently not used . When used you have to fix the color selection   public function drawLine($y, $xdata, $ydata, $ylabels, $ymin = false, $ymax = false, $band = false )   {      if (is_array($ydata) == false || count(reset($ydata)) == 0) {         return;      }      $markers = array( 4, 1, 2, 6, 3, 5, 7, 8, 9 );      $pg      = array();      $breite  = 480;      $hoehe   = 180;      $scale   = 2;      $rand = rand() . time();      $imageFilePath = $this->_materialPath . "jpgraph_{$rand}.png";      $graph = new Graph($breite * $scale, $hoehe * $scale);      if ($ymin !== false && $ymax !== false) {         $graph->SetScale('textlin', $ymin, $ymax);      } else {         $graph->SetScale('textlin');      }      if (is_array($xdata) === true) {         $graph->xaxis->SetTickLabels( $xdata );      } else {         $graph->xaxis->HideLabels();      }      foreach ($ydata as $i => $bardata) {         $pg[$i] = new LinePlot($bardata);         $pg[$i]->SetWeight(1);         $pg[$i]->SetColor($this->_colors[$i]);         $pg[$i]->SetCenter();         $pg[$i]->value->Show();         $pg[$i]->value->setformat('%1.1f%%');         $pg[$i]->mark->SetType($markers[$i]);         $pg[$i]->mark->SetFillColor($this->_colors[$i]);         $pg[$i]->SetLegend($ylabels[$i]);         $graph->Add($pg[$i]);      }      $graph->legend->SetLayout( 1 );      $graph->legend->Pos( 0.5, 0.99, 'center', 'bottom');      // ggf. Plotband setzen      if (is_array($band) === true) {         $b = new PlotBand( HORIZONTAL, 1, $band['min'], $band['max'], '#CCFFCC' );         $b->SetDensity( 95 );         $b->SetOrder( 0 );         $b->ShowFrame( false );         $graph->AddBand( $b );      }      $graph->SetFrame( false );      $graph->Stroke( $imageFilePath );      // Graph einbinden und danach die Image-Datei löschen      $this->_fpdi->Image($imageFilePath, $this->_pageMarginLeft, $y, $breite, $hoehe );      unlink( $imageFilePath );   } **/    /**     * kaplan meier diagramm     *     * @param $y     * @param $dauer     * @param $ereignis    */    public function kaplanMeier($dataArray, $title = null, $y = null, $height = null)    {        $subhead = null;        if ($title !== null && is_array($title) === true) {            $subhead = end($title);            $title = reset($title);        }        if ((array_key_exists('range', $dataArray) === false || array_key_exists('event', $dataArray) === false) ||            count($dataArray['range']) !== count($dataArray['event'])        ) {            echo 'Please check $dataArray structure';            exit;        }        $y = $y === null ? $this->getFPDI()->GetY() : $y;        $this->_sortKaplanMeier($dataArray);        // Init        $xdata   = array();        $ydata   = array();        $s = kaplanMeierAlgorithm($dataArray);        // Umwandlung in Daten für Diagramm-Ausgabe        $previous_s = 1;        foreach ($s as $t => $cur_s) {            $xdata[] = $t;            $xdata[] = $t;            $ydata[] = $previous_s * 100;            $ydata[] = $cur_s * 100;            $previous_s = $cur_s;        }        // Diagramm generieren und ausgeben        $orientation  = $this->getFPDI()->getCurrentPageOrientation();        $width        = $this->_pageWidth[$orientation] - ($this->_pageMarginLeft + $this->_pageMarginRight);        $height       = $height !== null ? $height : ($orientation == 'l' ? 450 : 700);        $scale        = 2;        $rand = rand() . time();        $imageFilePath = $this->_materialPath . "jpgraph_{$rand}.png";        $graph = new Graph($width * $scale, $height * $scale);        $graph->SetScale('intlin', 0, 100);        $graph->xaxis->title->Set('Dauer [Monate]');        $graph->xaxis->setlabelformat('%1.0f');        $graph->yaxis->setlabelformat('%1.0f%%');        $plot = new ScatterPlot($ydata, $xdata);        $plot->SetLinkPoints(true);        $graph->Add($plot);        $graph->SetFrame(false);        //SetMargin($aLeft,$aRight,$aTop,$aBottom        $marginTop = $title !== null && $subhead !== null            ? 70            : ($title !== null ? 45 : 10)        ;        $graph->SetMargin(40, 10, $marginTop, 75);        $graph->Stroke($imageFilePath);        // Graph einbinden und danach die Image-Datei löschen        $this->getFPDI()->Image($imageFilePath, $this->_pageMarginLeft, $y, $width, $height);        unlink($imageFilePath);        //Titel malen wenn vorhanden        if ($title !== null) {            $this->getFPDI()->SetFontSize($this->_fontSizeBigger);            $this->getFPDI()->Text($this->_pageMarginLeft, $y, $title);        }        if ($subhead !== null) {            $newY = $y + 15;            $this->getFPDI()->SetFontSize($this->_fontSizeNormal);            $this->getFPDI()->Text($this->_pageMarginLeft, $newY, $subhead);        }   }    public function kaplanMeierMulti($dataArray, $title = null, $y = null, $height = null)    {        $subhead = null;        if ($title !== null && is_array($title) === true) {            $subhead = end($title);            $title = reset($title);        }        if ((array_key_exists('range', $dataArray) === false || array_key_exists('event', $dataArray) === false || array_key_exists('legend', $dataArray) === false) ||            count($dataArray['range']) !== count($dataArray['event']) || count($dataArray['range']) !== count($dataArray['legend'])        ) {            echo 'Please check $dataArray structure';            exit;        }        $this->_sortKaplanMeier($dataArray);        $legende    = $dataArray['legend'];        $dauer      = $dataArray['range'];        $ereignis   = $dataArray['event'];        $type       = array_key_exists('type', $dataArray) == true ? $dataArray['type'] : 'base';        $orientation    = $this->getFPDI()->getCurrentPageOrientation();        $width          = $this->_pageWidth[$orientation] - ($this->_pageMarginLeft + $this->_pageMarginRight);        $height         = $height !== null ? $height : ($orientation == 'l' ? 450 : 700);        $scale          = 2;        $y              = $y === null ? $this->getFPDI()->GetY() : $y;        $rand = rand() . time();        $imageFilePath = $this->_materialPath . "jpgraph_{$rand}.png";        $graph = new Graph($width * $scale, $height * $scale);        $graph->SetScale( 'intlin', 0, 100 );        $graph->xaxis->title->Set('Dauer [Monate]');        $graph->xaxis->setlabelformat( '%1.0f' );        $graph->yaxis->setlabelformat( '%1.0f%%' );        // Data Init        $final_data = array();        foreach ($legende as $i => $t)        {          $final_data[$t]['range'][$i]  = $dauer[$i];          $final_data[$t]['event'][$i]  = $ereignis[$i];        }        ksort($final_data);        $final_data['Gesamt']['range'] = $dauer;        $final_data['Gesamt']['event'] = $ereignis;        $x = 0;        foreach ($final_data AS $name => $data)        {            $xdata   = array();            $ydata   = array();            $s = kaplanMeierAlgorithm($data);            // Umwandlung in Daten für Diagramm-Ausgabe            $previous_s = 1;            foreach ($s as $t => $cur_s)            {                $xdata[] = $t;                $xdata[] = $t;                $ydata[] = $previous_s * 100;                $ydata[] = $cur_s * 100;                $previous_s = $cur_s;            }            $color = $this->_colors[$type][strtolower($name)];            $plot = new ScatterPlot( $ydata, $xdata );            $plot->SetLinkPoints( true, $color, 2 );            $plot->mark->SetFillColor( $color );            $plot->SetLegend( "" . $name );            $graph->Add($plot);            $x++;        }        $graph->legend->SetLayout( 2 );        $graph->legend->Pos( 0.5, 0.99, 'center', 'bottom');        $graph->SetFrame( false );        $marginTop = $title !== null && $subhead !== null            ? 70            : ($title !== null ? 45 : 10)        ;        $graph->SetMargin(40, 10, $marginTop, 75);        $graph->Stroke($imageFilePath);        $this->getFPDI()->Image($imageFilePath, $this->_pageMarginLeft, $y, $width, $height);        unlink($imageFilePath);        //Titel malen wenn vorhanden        if ($title !== null) {            $this->getFPDI()->SetFontSize($this->_fontSizeBigger);            $this->getFPDI()->Text($this->_pageMarginLeft, $y, $title);        }        if ($subhead !== null) {            $newY = $y + 15;            $this->getFPDI()->SetFontSize($this->_fontSizeNormal);            $this->getFPDI()->Text($this->_pageMarginLeft, $newY, $subhead);        }    }    /**     * sorts kaplan meier     *     * @param $dataArray     */    private function _sortKaplanMeier(&$dataArray)    {        $otherParts = array();        foreach ($dataArray as $k => $v) {            if (in_array($k, array('range', 'event', 'legend')) === false) {                $otherParts[$k] = $dataArray[$k];            }        }        $tmp = array('range' => array(), 'event' => array(), 'legend' => array());        asort($dataArray['range']);        foreach ($dataArray['range'] as $i => $range) {            //Range darf nicht im Minusbereich liegen            if ($range >= 0) {                $tmp['range'][] = $range;                $tmp['event'][] = $dataArray['event'][$i];                if (array_key_exists('legend', $dataArray) === true) {                     $tmp['legend'][] = $dataArray['legend'][$i];                }            }        }        $dataArray = array_merge($otherParts, $tmp);    }    /*    public function barSingle($y, $xdata, $ydata )    {       if( ! is_array( $ydata ) )          return;       if( count( $ydata ) == 0 )          return;       $pg = array();       $breite  = 480;       $hoehe   = 180;       $scale   = 2;       $rand = rand() . time();       $image_file = './material/jpgraph_' . $rand . '.png';       $graph = new Graph( $breite * $scale, $hoehe * $scale );       $graph->SetScale( 'textlin' );       if( is_array( $xdata ) )          $graph->xaxis->SetTickLabels( $xdata );       else          $graph->xaxis->HideLabels();       $p1 = new BarPlot( $ydata );       $p1->SetFillColor( '#BDBFEC' );       $p1->value->Show();       $p1->value->setformat( '%1.0f' );       $pg[] = $p1;       $gbarplot = new GroupBarPlot( $pg );       $gbarplot->SetWidth( 0.7 );       $graph->Add( $gbarplot );       $graph->SetFrame( false );       $graph->Stroke( $image_file );       // Graph einbinden und danach die Image-Datei löschen       $pdf->fpdf->Image( $image_file, BORDER_LEFT, $y + GRAPH_OFFSET_Y, $breite, $hoehe );       unlink( $image_file );    }   */    /**     * builds graph colors which are given via param     */    protected function _buildGraphColors()    {        foreach ($this->_params as $name => $value) {            if (strpos($name, 'chart_') !== false) {                $parts = explode('-', substr($name, 6));                $this->_colors[reset($parts)][end($parts)] = $value;            }        }    }}?>